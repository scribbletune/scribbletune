// Generated by dts-bundle v0.7.3

export { getScale as scale, getScale as mode, scales, scales as modes, addChord, getChord as chord, chords, clip, getChordDegrees, getChordsByProgression, progression, arp, midi, Session, max, };

export const getScale: (tonicOctScale: string) => (string | null)[];
export const scales: () => string[];

/**
    * Derive a chord from the given string. Exposed as simply `chord` in Scribbletune
    * @return {Array}     [example `chord('CM')` outputs: ['c4', 'e4', 'g4'], `chord('CM-5')` outputs: ['c5', 'e5', 'g5']]
    */
export const getChord: (name: string) => string[] | (string | null)[] | null;
/**
    * Get a list of chords available in Scribbletune.
    * @return {Array}     [example output: ['maj', 'min', 'dim']]
    */
export const chords: () => string[];
/**
    * Adds a chord to Tonal's chord collection, so getChord can access it.
    * @param  {<Array>String} intervals e.g. ['1P', '3M', '5P']
    * @param  {<Array>String} abbrev e.g. ['Q', 'T']
    * @param  {String} name e.g. full
    * @return {void}
    */
export const addChord: (intervals: string[], abbrev: string[], name?: string | undefined) => void;

export const clip: (params: ClipParams) => any;

/**
    * Get the chords that go with a given scale/mode
    * This is useful only in case you want to check what chords work with a scale/mode
    * so that you can come up with chord progressions
    * @param  {String} mode e.g. major
    * @return {Array} e.g.['I', 'ii', 'iii', 'IV', 'V', 'vi', 'viiÂ°']
    */
export const getChordDegrees: (mode: string) => string[];
/**
    * Take the specified scale and degrees and return the chord names for them
    * These can be used as the value for the `notes` param of the `clip` method
    * @param {String} noteOctaveScale e.g. 'C4 major'
    * @param  {String} chordDegress e.g. 'I IV V IV'
    * @return {String} e.g. 'CM FM GM FM'
    */
export const getChordsByProgression: (noteOctaveScale: string, chordDegress: string) => string;
/**
    * Generate a chord progression based on basic music theory
    * where we follow tonic to optionally predominant and then dominant
    * and then randomly to predominant and continue this till we reach `count`
    * @param scale e.g. M (for major chord progression), m (for minor chord progression)
    * @param count e.g. 4
    */
export const progression: (scale: progressionScale, count?: number) => any[] | undefined;

type Params = {
    count: number;
    order?: string;
    chords: string;
};
/**
  *
  * @param chordsOrParams a string that denotes comma separated chords to be used or an object with additional properties
  * By default, if this is a string, the the count of notes generated is 8 and the order is ascending.
  * For instance arp('CM FM') will result in an array of notes [C4, E4, G4, F4, A4, C4, C5, E5]
  * You can even provide Params as an object.
  * For e.g. arp({count: 8, order: '10325476', chords: 'FM-4 Gm7b5-4 AbM-4 Bbm-4 Cm-5 DbM-5 EbM-5})
  */
export const arp: (chordsOrParams: string | Params) => any;
export {};

/**
  * Take an array of note objects to generate a MIDI file in the same location as this method is called
  * @param  {<Array>NoteObject} notes    Notes are in the format: {note: ['c3'], level: 127, length: 64}
  * @param  {String | null} fileName If a filename is not provided, then `music.mid` is used by default
  * If `null` is passed for `fileName`, bytes are returned instead of creating a file
  * If this method is called from a browser then it will return a HTML link that you can append in your page
  * This link will enable the generated MIDI as a downloadable file.
  * @param {Number | null} bpm If a value is provided, the generated midi file will be set to this bpm value.
  */
export const midi: (notes: NoteObject[], fileName?: string | null, bpm?: number | undefined) => string | HTMLAnchorElement | undefined;

export class Session {
    sessionChannels: Channel[];
    constructor(arr: ChannelParams[]);
    createChannel(ch: ChannelParams): Channel;
    get channels(): Channel[];
    startRow(idx: number): void;
}

/**
  * Take an array of note objects to populate a clip selected in Ableton Live via Max4Live
  * @param  {<Array>NoteObject} notes    Notes are in the format: {note: ['c3'], level: 127, length: 64}
  */
export const max: (notes: NoteObject[], liveClip?: string) => void;

/**
  * Channel
  * A channel is made up of a Tone.js Player/Instrument, one or more
  * Tone.js sequences (known as clips in Scribbletune)
  * & optionally a set of effects (with or without presets)
  *
  * API:
  * clips -> Get all clips for this channel
  * addClip -> Add a new clip to the channel
  * startClip -> Start a clip at the provided index
  * stopClip -> Stop a clip at the provided index
  * activeClipIdx -> Get the clip that is currently playing
  */
export class Channel {
    idx: number;
    activePatternIdx: number;
    channelClips: any;
    player: any;
    instrument: any;
    sampler: any;
    constructor(params: ChannelParams);
    get clips(): any;
    startClip(idx: number): void;
    stopClip(idx: number): void;
    addClip(clipParams: any, idx?: number): void;
    get activeClipIdx(): number;
}

